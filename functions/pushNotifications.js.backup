/**
 * Complete Push Notifications Module for AMENAPP
 * Compatible with Firebase Functions v7 (2nd generation)
 *
 * Includes ALL notification types:
 * - Follow/Unfollow
 * - Follow Requests
 * - Comments
 * - Replies
 * - Mentions
 * - Likes/Amens
 * - Reposts
 * - Messages
 */

const {onDocumentCreated, onDocumentDeleted} = require("firebase-functions/v2/firestore");
const {onCall} = require("firebase-functions/v2/https");
const admin = require("firebase-admin");

const db = admin.firestore();

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Check if user has enabled a specific notification type
 * @param {string} userId - User ID to check preferences for
 * @param {string} notificationType - Type of notification (follows, comments, amens, mentions, messages, etc.)
 * @return {Promise<boolean>} - True if notification is enabled, false otherwise
 */
async function checkNotificationPreference(userId, notificationType) {
  try {
    const userDoc = await db.collection("users").doc(userId).get();

    if (!userDoc.exists) {
      console.log(`‚ö†Ô∏è User ${userId} not found, assuming notifications enabled`);
      return true; // Default to enabled if user not found
    }

    const userData = userDoc.data();
    const settings = userData?.notificationSettings || {};

    // Map notification type to settings key
    const settingsKey = {
      'follow': 'follows',
      'comment': 'comments',
      'reply': 'comments', // Replies use comments setting
      'amen': 'amens',
      'mention': 'mentions',
      'message': 'messages',
      'repost': 'communityUpdates',
      'prayerRequest': 'prayerRequests',
    }[notificationType];

    // If setting not found, default to enabled
    if (!settingsKey) {
      console.log(`‚ö†Ô∏è Unknown notification type: ${notificationType}, assuming enabled`);
      return true;
    }

    const isEnabled = settings[settingsKey] !== false; // Default to true if not set

    if (!isEnabled) {
      console.log(`üîï User ${userId} has disabled ${notificationType} notifications`);
    }

    return isEnabled;
  } catch (error) {
    console.error(`‚ùå Error checking notification preference for ${userId}:`, error);
    return true; // Default to enabled on error
  }
}

/**
 * Send push notification to user (with preference check)
 * @param {string} userId - User to send notification to
 * @param {string} title - Notification title
 * @param {string} body - Notification body
 * @param {object} data - Additional data
 * @param {string} notificationType - Type for preference check
 * @return {Promise<object>} - Result object
 */
async function sendPushNotificationToUser(userId, title, body, data = {}, notificationType = null) {
  try {
    // Check notification preferences if type provided
    if (notificationType) {
      const isEnabled = await checkNotificationPreference(userId, notificationType);
      if (!isEnabled) {
        console.log(`üîï Notification skipped (user preference): ${notificationType} for ${userId}`);
        return {success: false, reason: 'user_preference_disabled'};
      }
    }

    const userDoc = await db.collection("users").doc(userId).get();
    const userData = userDoc.data();
    const fcmToken = userData?.fcmToken;

    if (!fcmToken) {
      console.log(`‚ö†Ô∏è No FCM token for user ${userId}`);
      return null;
    }

    const message = {
      notification: {
        title,
        body,
      },
      data,
      token: fcmToken,
    };

    await admin.messaging().send(message);
    console.log(`‚úÖ Push notification sent to ${userId}`);
    return {success: true};
  } catch (error) {
    console.error(`‚ùå Error sending push notification to ${userId}:`, error);
    return {success: false, error: error.message};
  }
}

// ============================================================================
// 1. FOLLOW NOTIFICATIONS (Already Deployed)
// ============================================================================

exports.onUserFollow = onDocumentCreated(
    {document: "follows/{followId}"},
    async (event) => {
      const followData = event.data.data();
      const {followerId, followingId} = followData;

      if (!followerId || !followingId) {
        console.log("‚ö†Ô∏è Missing followerId or followingId");
        return null;
      }

      try {
        const followerDoc = await db.collection("users").doc(followerId).get();

        if (!followerDoc.exists) {
          console.log("‚ö†Ô∏è Follower user not found");
          return null;
        }

        const followerData = followerDoc.data();
        // ‚úÖ FIX: Multiple fallbacks to prevent "undefined" in notifications
        const followerName = followerData?.displayName ||
                            followerData?.username ||
                            followerData?.email?.split('@')[0] ||
                            "Someone";

        // ‚úÖ NEW: Include profile photo for Instagram-speed display
        const actorProfileImageURL = followerData?.profileImageURL ||
                                     followerData?.profilePictureURL ||
                                     "";

        const notification = {
          type: "follow",
          actorId: followerId,
          actorName: followerName,
          actorUsername: followerData?.username || "",
          actorProfileImageURL: actorProfileImageURL,  // ‚úÖ NEW
          userId: followingId,
          read: false,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        };

        // ‚úÖ IDEMPOTENCY: Use deterministic ID (follow_actorId_userId)
        // This ensures only ONE notification exists per follower-followed pair
        const notificationId = `follow_${followerId}_${followingId}`;

        await db.collection("users")
            .doc(followingId)
            .collection("notifications")
            .doc(notificationId)
            .set(notification, {merge: true});

        console.log(`‚úÖ Follow notification created for ${followingId} from ${followerName}`);

        // ‚úÖ NEW: Check user preference before sending push
        await sendPushNotificationToUser(
            followingId,
            "New Follower",
            `${followerName} started following you`,
            {
              type: "follow",
              actorId: followerId,
              actorName: followerName,
            },
            "follow", // Notification type for preference check
        );

        return null;
      } catch (error) {
        console.error("‚ùå Error in onUserFollow:", error);
        return null;
      }
    },
);

exports.onUserUnfollow = onDocumentDeleted(
    {document: "follows/{followId}"},
    async (event) => {
      const followData = event.data.data();
      const {followerId, followingId} = followData;

      if (!followerId || !followingId) {
        console.log("‚ö†Ô∏è Missing followerId or followingId");
        return null;
      }

      try {
        // ‚úÖ IDEMPOTENCY: Use the same deterministic ID
        const notificationId = `follow_${followerId}_${followingId}`;

        await db.collection("users")
            .doc(followingId)
            .collection("notifications")
            .doc(notificationId)
            .delete();

        console.log(`‚úÖ Deleted follow notification for ${followingId}`);

        return null;
      } catch (error) {
        console.error("‚ùå Error in onUserUnfollow:", error);
        return null;
      }
    },
);

// ============================================================================
// 2. COMMENT NOTIFICATIONS (NEW)
// ============================================================================

exports.onCommentCreate = onDocumentCreated(
    {document: "posts/{postId}/comments/{commentId}"},
    async (event) => {
      const {postId} = event.params;
      const commentData = event.data.data();

      try {
        // Get post to find the author
        const postDoc = await db.collection("posts").doc(postId).get();
        const postData = postDoc.data();

        if (!postData) {
          console.log("‚ö†Ô∏è Post not found");
          return null;
        }

        const postAuthorId = postData.authorId;
        const commentAuthorId = commentData.userId || commentData.authorId;

        // Don't notify if user comments on their own post
        if (postAuthorId === commentAuthorId) {
          return null;
        }

        // Get commenter's profile
        const commenterDoc = await db.collection("users").doc(commentAuthorId).get();
        const commenterData = commenterDoc.data();
        const commenterName = commenterData?.displayName || "Someone";

        // ‚úÖ NEW: Include profile photo
        const actorProfileImageURL = commenterData?.profileImageURL ||
                                     commenterData?.profilePictureURL ||
                                     "";

        // Create notification
        const notification = {
          type: "comment",
          actorId: commentAuthorId,
          actorName: commenterName,
          actorUsername: commenterData?.username || "",
          actorProfileImageURL: actorProfileImageURL,  // ‚úÖ NEW
          postId: postId,
          commentText: commentData.text,
          userId: postAuthorId,
          read: false,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
          commentCount: 1, // ‚úÖ For Threads-style grouping
        };

        // ‚úÖ IDEMPOTENCY: Use deterministic ID (comment_actorId_postId)
        // Multiple comments from same person get merged into one notification
        const notificationId = `comment_${commentAuthorId}_${postId}`;

        await db.collection("users")
            .doc(postAuthorId)
            .collection("notifications")
            .doc(notificationId)
            .set(notification, {merge: true});

        console.log(`‚úÖ Comment notification created for ${postAuthorId}`);

        // ‚úÖ NEW: Send push notification with preference check
        await sendPushNotificationToUser(
            postAuthorId,
            "New Comment",
            `${commenterName} commented on your post`,
            {
              type: "comment",
              actorId: commentAuthorId,
              postId: postId,
            },
            "comment", // Notification type for preference check
        );

        return null;
      } catch (error) {
        console.error("‚ùå Error in onCommentCreate:", error);
        return null;
      }
    },
);

// ============================================================================
// 3. REPLY NOTIFICATIONS (NEW)
// ============================================================================

exports.onCommentReply = onDocumentCreated(
    {document: "posts/{postId}/comments/{commentId}"},
    async (event) => {
      const {postId} = event.params;
      const commentData = event.data.data();

      // Only process if this is a reply (has parentCommentId)
      if (!commentData.parentCommentId) {
        return null;
      }

      try {
        // Get parent comment to find who to notify
        const parentCommentDoc = await db.collection("posts")
            .doc(postId)
            .collection("comments")
            .doc(commentData.parentCommentId)
            .get();

        if (!parentCommentDoc.exists) {
          console.log("‚ö†Ô∏è Parent comment not found");
          return null;
        }

        const parentCommentData = parentCommentDoc.data();
        const parentCommentAuthorId = parentCommentData.userId || parentCommentData.authorId;
        const replyAuthorId = commentData.userId || commentData.authorId;

        // Don't notify if user replies to their own comment
        if (parentCommentAuthorId === replyAuthorId) {
          return null;
        }

        // Get replier's profile
        const replierDoc = await db.collection("users").doc(replyAuthorId).get();
        const replierData = replierDoc.data();
        const replierName = replierData?.displayName || "Someone";

        // ‚úÖ NEW: Include profile photo
        const actorProfileImageURL = replierData?.profileImageURL ||
                                     replierData?.profilePictureURL ||
                                     "";

        // Create notification
        const notification = {
          type: "reply",
          actorId: replyAuthorId,
          actorName: replierName,
          actorUsername: replierData?.username || "",
          actorProfileImageURL: actorProfileImageURL,  // ‚úÖ NEW
          postId: postId,
          commentText: commentData.text,
          userId: parentCommentAuthorId,
          read: false,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        };

        await db.collection("users")
            .doc(parentCommentAuthorId)
            .collection("notifications")
            .add(notification);

        console.log(`‚úÖ Reply notification created for ${parentCommentAuthorId}`);

        // Send push notification
        await sendPushNotificationToUser(
            parentCommentAuthorId,
            "New Reply",
            `${replierName} replied to your comment`,
            {
              type: "reply",
              actorId: replyAuthorId,
              postId: postId,
            },
        );

        return null;
      } catch (error) {
        console.error("‚ùå Error in onCommentReply:", error);
        return null;
      }
    },
);

// ============================================================================
// 4. MENTION NOTIFICATIONS (NEW)
// ============================================================================

exports.onPostCreate = onDocumentCreated(
    {document: "posts/{postId}"},
    async (event) => {
      const postData = event.data.data();
      const {postId} = event.params;

      // Extract mentions from post content (simple regex for @username)
      const mentionRegex = /@(\w+)/g;
      const mentions = [...postData.content.matchAll(mentionRegex)]
          .map((match) => match[1]);

      if (mentions.length === 0) {
        return null;
      }

      try {
        // Get author's profile
        const authorDoc = await db.collection("users").doc(postData.authorId).get();
        const authorData = authorDoc.data();
        const authorName = authorData?.displayName || "Someone";

        // ‚úÖ NEW: Include profile photo
        const actorProfileImageURL = authorData?.profileImageURL ||
                                     authorData?.profilePictureURL ||
                                     "";

        // Create notification for each mentioned user
        const batch = db.batch();

        for (const username of mentions) {
          // Find user by username
          const userQuery = await db.collection("users")
              .where("username", "==", username)
              .limit(1)
              .get();

          if (!userQuery.empty) {
            const mentionedUserDoc = userQuery.docs[0];
            const mentionedUserId = mentionedUserDoc.id;

            // Don't notify if user mentions themselves
            if (mentionedUserId === postData.authorId) {
              continue;
            }

            const notificationRef = db.collection("users")
                .doc(mentionedUserId)
                .collection("notifications")
                .doc();

            batch.set(notificationRef, {
              type: "mention",
              actorId: postData.authorId,
              actorName: authorName,
              actorUsername: authorData?.username || "",
              actorProfileImageURL: actorProfileImageURL,  // ‚úÖ NEW
              postId: postId,
              userId: mentionedUserId,
              read: false,
              createdAt: admin.firestore.FieldValue.serverTimestamp(),
            });

            // Send push notification
            await sendPushNotificationToUser(
                mentionedUserId,
                "You were mentioned",
                `${authorName} mentioned you in a post`,
                {
                  type: "mention",
                  actorId: postData.authorId,
                  postId: postId,
                },
            );
          }
        }

        await batch.commit();
        console.log(`‚úÖ Mention notifications created for ${mentions.length} users`);

        return null;
      } catch (error) {
        console.error("‚ùå Error in onPostCreate:", error);
        return null;
      }
    },
);

// ============================================================================
// 5. LIKE/AMEN NOTIFICATIONS (NEW)
// ============================================================================

exports.onAmenCreate = onDocumentCreated(
    {document: "posts/{postId}/likes/{likeId}"},
    async (event) => {
      const {postId} = event.params;
      const likeData = event.data.data();

      try {
        // Get post to find the author
        const postDoc = await db.collection("posts").doc(postId).get();
        const postData = postDoc.data();

        if (!postData) {
          console.log("‚ö†Ô∏è Post not found");
          return null;
        }

        const postAuthorId = postData.authorId;
        const likerUserId = likeData.userId;

        // Don't notify if user likes their own post
        if (postAuthorId === likerUserId) {
          return null;
        }

        // Get liker's profile
        const likerDoc = await db.collection("users").doc(likerUserId).get();
        const likerData = likerDoc.data();
        const likerName = likerData?.displayName || "Someone";

        // ‚úÖ NEW: Include profile photo
        const actorProfileImageURL = likerData?.profileImageURL ||
                                     likerData?.profilePictureURL ||
                                     "";

        // ‚úÖ THREADS-STYLE GROUPING: Use grouped notification per post
        // Check if there's already a grouped notification for this post
        const groupedNotificationId = `amen_group_${postId}`;
        const notificationRef = db.collection("users")
            .doc(postAuthorId)
            .collection("notifications")
            .doc(groupedNotificationId);

        const existingNotif = await notificationRef.get();

        if (existingNotif.exists) {
          // Update existing grouped notification
          const existingData = existingNotif.data();
          const actors = existingData.actors || [];

          // Check if this user is already in the actors list
          const userExists = actors.some(actor => actor.id === likerUserId);

          if (!userExists) {
            // Add new actor to the beginning (most recent first)
            actors.unshift({
              id: likerUserId,
              name: likerName,
              username: likerData?.username || "",
              profileImageURL: actorProfileImageURL,
            });

            await notificationRef.update({
              actors: actors,
              actorCount: actors.length,
              actorId: likerUserId, // Most recent actor
              actorName: likerName,
              actorUsername: likerData?.username || "",
              actorProfileImageURL: actorProfileImageURL,
              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
              read: false, // Mark as unread when new activity occurs
            });

            console.log(`‚úÖ Updated grouped amen notification (${actors.length} users)`);
          }
        } else {
          // Create new grouped notification
          const notification = {
            type: "amen",
            actorId: likerUserId,
            actorName: likerName,
            actorUsername: likerData?.username || "",
            actorProfileImageURL: actorProfileImageURL,
            postId: postId,
            userId: postAuthorId,
            read: false,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
            // Threads-style grouping fields
            actors: [{
              id: likerUserId,
              name: likerName,
              username: likerData?.username || "",
              profileImageURL: actorProfileImageURL,
            }],
            actorCount: 1,
          };

          await notificationRef.set(notification);
          console.log(`‚úÖ Created new grouped amen notification`);
        }

        console.log(`‚úÖ Amen notification created for ${postAuthorId}`);

        // Send push notification
        await sendPushNotificationToUser(
            postAuthorId,
            "New Amen",
            `${likerName} amened your post`,
            {
              type: "amen",
              actorId: likerUserId,
              postId: postId,
            },
        );

        return null;
      } catch (error) {
        console.error("‚ùå Error in onAmenCreate:", error);
        return null;
      }
    },
);

exports.onAmenDelete = onDocumentDeleted(
    {document: "posts/{postId}/likes/{likeId}"},
    async (event) => {
      const {postId} = event.params;
      const likeData = event.data.data();

      try {
        // Get post author
        const postDoc = await db.collection("posts").doc(postId).get();
        const postData = postDoc.data();

        if (!postData) return null;

        // ‚úÖ THREADS-STYLE GROUPING: Remove user from grouped notification
        const groupedNotificationId = `amen_group_${postId}`;
        const notificationRef = db.collection("users")
            .doc(postData.authorId)
            .collection("notifications")
            .doc(groupedNotificationId);

        const existingNotif = await notificationRef.get();

        if (existingNotif.exists) {
          const existingData = existingNotif.data();
          const actors = existingData.actors || [];

          // Remove this user from actors list
          const updatedActors = actors.filter(actor => actor.id !== likeData.userId);

          if (updatedActors.length === 0) {
            // No more actors - delete the notification
            await notificationRef.delete();
            console.log(`‚úÖ Deleted grouped amen notification (no more actors)`);
          } else {
            // Update with remaining actors
            const mostRecentActor = updatedActors[0];
            await notificationRef.update({
              actors: updatedActors,
              actorCount: updatedActors.length,
              actorId: mostRecentActor.id,
              actorName: mostRecentActor.name,
              actorUsername: mostRecentActor.username || "",
              actorProfileImageURL: mostRecentActor.profileImageURL || "",
              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
            });

            console.log(`‚úÖ Updated grouped amen notification (${updatedActors.length} users remaining)`);
          }
        }

        console.log(`‚úÖ Processed amen deletion for ${postData.authorId}`);

        return null;
      } catch (error) {
        console.error("‚ùå Error in onAmenDelete:", error);
        return null;
      }
    },
);

// ============================================================================
// 6. REPOST NOTIFICATIONS (NEW)
// ============================================================================

exports.onRepostCreate = onDocumentCreated(
    {document: "reposts/{repostId}"},
    async (event) => {
      const repostData = event.data.data();

      try {
        // Get original post to find the author
        const postDoc = await db.collection("posts").doc(repostData.postId).get();
        const postData = postDoc.data();

        if (!postData) {
          console.log("‚ö†Ô∏è Post not found");
          return null;
        }

        const postAuthorId = postData.authorId;
        const reposterId = repostData.userId;

        // Don't notify if user reposts their own post
        if (postAuthorId === reposterId) {
          return null;
        }

        // Get reposter's profile
        const reposterDoc = await db.collection("users").doc(reposterId).get();
        const reposterData = reposterDoc.data();
        const reposterName = reposterData?.displayName || "Someone";

        // ‚úÖ NEW: Include profile photo
        const actorProfileImageURL = reposterData?.profileImageURL ||
                                     reposterData?.profilePictureURL ||
                                     "";

        // Create notification
        const notification = {
          type: "repost",
          actorId: reposterId,
          actorName: reposterName,
          actorUsername: reposterData?.username || "",
          actorProfileImageURL: actorProfileImageURL,  // ‚úÖ NEW
          postId: repostData.postId,
          userId: postAuthorId,
          read: false,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        };

        await db.collection("users")
            .doc(postAuthorId)
            .collection("notifications")
            .add(notification);

        console.log(`‚úÖ Repost notification created for ${postAuthorId}`);

        // Send push notification
        await sendPushNotificationToUser(
            postAuthorId,
            "Post Reposted",
            `${reposterName} reposted your post`,
            {
              type: "repost",
              actorId: reposterId,
              postId: repostData.postId,
            },
        );

        return null;
      } catch (error) {
        console.error("‚ùå Error in onRepostCreate:", error);
        return null;
      }
    },
);

// ============================================================================
// 7. FOLLOW REQUEST NOTIFICATIONS (Already Deployed)
// ============================================================================

exports.onFollowRequestAccepted = onDocumentCreated(
    {document: "followRequests/{requestId}"},
    async (event) => {
      const requestData = event.data.data();
      const {fromUserId, toUserId, status} = requestData;

      if (status !== "accepted") {
        return null;
      }

      if (!fromUserId || !toUserId) {
        console.log("‚ö†Ô∏è Missing fromUserId or toUserId");
        return null;
      }

      try {
        const toUserDoc = await db.collection("users").doc(toUserId).get();
        const toUserData = toUserDoc.data();
        const toUserName = toUserData?.displayName || "Someone";

        const notification = {
          type: "followRequestAccepted",
          actorId: toUserId,
          actorName: toUserName,
          userId: fromUserId,
          read: false,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        };

        await db.collection("users")
            .doc(fromUserId)
            .collection("notifications")
            .add(notification);

        console.log(`‚úÖ Follow request accepted notification created for ${fromUserId}`);

        await sendPushNotificationToUser(
            fromUserId,
            "Follow Request Accepted",
            `${toUserName} accepted your follow request`,
            {
              type: "followRequestAccepted",
              actorId: toUserId,
            },
        );

        return null;
      } catch (error) {
        console.error("‚ùå Error in onFollowRequestAccepted:", error);
        return null;
      }
    },
);

// ============================================================================
// 8. MESSAGE NOTIFICATIONS (Already Deployed)
// ============================================================================

exports.onMessageRequestAccepted = onDocumentCreated(
    {document: "conversations/{conversationId}"},
    async (event) => {
      const conversationData = event.data.data();
      const {participantIds, conversationStatus} = conversationData;

      if (conversationStatus !== "accepted" || !participantIds || participantIds.length !== 2) {
        return null;
      }

      try {
        const [user1Id, user2Id] = participantIds;

        const user1Doc = await db.collection("users").doc(user1Id).get();
        const user2Doc = await db.collection("users").doc(user2Id).get();

        const user1Data = user1Doc.data();
        const user2Data = user2Doc.data();

        const user1Name = user1Data?.displayName || "Someone";
        const user2Name = user2Data?.displayName || "Someone";

        await sendPushNotificationToUser(
            user1Id,
            "Message Request Accepted",
            `${user2Name} accepted your message request`,
            {
              type: "messageRequestAccepted",
              actorId: user2Id,
              conversationId: event.params.conversationId,
            },
        );

        await sendPushNotificationToUser(
            user2Id,
            "New Conversation",
            `You can now message ${user1Name}`,
            {
              type: "messageRequestAccepted",
              actorId: user1Id,
              conversationId: event.params.conversationId,
            },
        );

        console.log("‚úÖ Message request accepted notifications sent");

        return null;
      } catch (error) {
        console.error("‚ùå Error in onMessageRequestAccepted:", error);
        return null;
      }
    },
);

// ============================================================================
// 9. POST MENTION NOTIFICATIONS
// ============================================================================

/**
 * Triggered when a new post is created
 * Sends mention notifications to all mentioned users
 */
exports.onPostCreated = onDocumentCreated(
    {document: "posts/{postId}"},
    async (event) => {
      const postData = event.data.data();
      const postId = event.params.postId;
      const {authorId, content, mentions} = postData;

      if (!mentions || mentions.length === 0) {
        console.log("üìù No mentions in post, skipping");
        return null;
      }

      try {
        // Get author data
        const authorDoc = await db.collection("users").doc(authorId).get();
        if (!authorDoc.exists) {
          console.log("‚ö†Ô∏è Author not found");
          return null;
        }

        const authorData = authorDoc.data();
        const authorName = authorData?.displayName || authorData?.username || "Someone";
        const authorUsername = authorData?.username || "";
        const authorProfileImageURL = authorData?.profileImageURL || "";

        // Get preview of post content (first 50 chars)
        const contentPreview = content.substring(0, 50) + (content.length > 50 ? "..." : "");

        // Send notification to each mentioned user
        const notificationPromises = mentions.map(async (mention) => {
          const mentionedUserId = mention.userId;

          // Don't notify if user mentioned themselves
          if (mentionedUserId === authorId) {
            console.log(`‚ö†Ô∏è User mentioned themselves, skipping`);
            return null;
          }

          // Create deterministic notification ID to prevent duplicates
          const notificationId = `mention_${authorId}_${postId}_${mentionedUserId}`;

          const notification = {
            type: "mention",
            actorId: authorId,
            actorName: authorName,
            actorUsername: authorUsername,
            actorProfileImageURL: authorProfileImageURL,
            postId: postId,
            commentText: contentPreview, // Preview of post content
            userId: mentionedUserId,
            read: false,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
          };

          // Save notification to Firestore with deterministic ID
          await db.collection("users")
              .doc(mentionedUserId)
              .collection("notifications")
              .doc(notificationId)
              .set(notification, {merge: true});

          console.log(`‚úÖ Mention notification created for @${mention.username}`);

          // Send push notification
          await sendPushNotificationToUser(
              mentionedUserId,
              `${authorName} mentioned you`,
              contentPreview,
              {
                type: "mention",
                postId: postId,
                actorId: authorId,
              },
          );

          return {success: true, userId: mentionedUserId};
        });

        await Promise.all(notificationPromises);
        console.log(`‚úÖ Sent ${mentions.length} mention notifications for post ${postId}`);
        return {success: true, count: mentions.length};
      } catch (error) {
        console.error("‚ùå Error in onPostCreated:", error);
        return null;
      }
    },
);

// ============================================================================
// 10. MESSAGE REACTION NOTIFICATIONS
// ============================================================================

exports.onMessageReaction = onDocumentCreated(
    {document: "conversations/{conversationId}/messages/{messageId}/reactions/{reactionId}"},
    async (event) => {
      const conversationId = event.params.conversationId;
      const messageId = event.params.messageId;
      const reactionData = event.data.data();

      console.log(`‚ù§Ô∏è New reaction on message ${messageId} in conversation ${conversationId}`);

      try {
        // Get the message to find the original sender
        const messageDoc = await db.collection("conversations")
            .doc(conversationId)
            .collection("messages")
            .doc(messageId)
            .get();

        if (!messageDoc.exists) {
          console.log("‚ö†Ô∏è Message not found");
          return null;
        }

        const messageData = messageDoc.data();
        const messageSenderId = messageData.senderId;
        const reactorId = reactionData.userId;
        const emoji = reactionData.emoji;

        // Don't notify if user reacts to their own message
        if (messageSenderId === reactorId) {
          console.log("‚è≠Ô∏è Skipping - user reacted to their own message");
          return null;
        }

        // Get reactor's profile
        const reactorDoc = await db.collection("users").doc(reactorId).get();
        const reactorData = reactorDoc.data();
        const reactorName = reactorData?.displayName ||
                           reactorData?.username ||
                           "Someone";
        const actorProfileImageURL = reactorData?.profileImageURL || "";

        // Create in-app notification
        const notification = {
          type: "messageReaction",
          actorId: reactorId,
          actorName: reactorName,
          actorUsername: reactorData?.username || "",
          actorProfileImageURL: actorProfileImageURL,
          userId: messageSenderId,
          conversationId: conversationId,
          messageId: messageId,
          emoji: emoji,
          read: false,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        };

        // Use deterministic ID to prevent duplicate notifications
        const notificationId = `messageReaction_${messageId}_${reactorId}_${emoji}`;

        await db.collection("users")
            .doc(messageSenderId)
            .collection("notifications")
            .doc(notificationId)
            .set(notification, {merge: true});

        console.log(`‚úÖ Message reaction notification created for ${messageSenderId}`);

        // Send push notification
        await sendPushNotificationToUser(
            messageSenderId,
            `${reactorName} reacted to your message`,
            `${emoji}`,
            {
              type: "messageReaction",
              conversationId: conversationId,
              messageId: messageId,
              actorId: reactorId,
            },
        );

        return null;
      } catch (error) {
        console.error("‚ùå Error in onMessageReaction:", error);
        return null;
      }
    },
);

// ============================================================================
// 11. MANUAL PUSH NOTIFICATION (Already Deployed)
// ============================================================================

exports.sendPushNotification = onCall(async (request) => {
  const {userId, title, body, data} = request.data;

  if (!userId || !title || !body) {
    throw new Error("Missing required parameters: userId, title, body");
  }

  try {
    const result = await sendPushNotificationToUser(userId, title, body, data || {});
    return result;
  } catch (error) {
    console.error("‚ùå Error in sendPushNotification:", error);
    throw new Error(`Failed to send notification: ${error.message}`);
  }
});
