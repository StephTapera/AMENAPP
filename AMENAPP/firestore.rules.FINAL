rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ========================================
    // HELPER FUNCTIONS
    // ========================================
    
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    // Check if user is blocked by another user
    function isBlocked(userId) {
      return exists(/databases/$(database)/documents/users/$(userId)/blockedUsers/$(request.auth.uid));
    }
    
    // Check if current user has blocked another user
    function hasBlocked(userId) {
      return exists(/databases/$(database)/documents/users/$(request.auth.uid)/blockedUsers/$(userId));
    }
    
    // Check if two users follow each other (mutual follow)
    function areFollowingEachOther(userId1, userId2) {
      return exists(/databases/$(database)/documents/follows/$(userId1 + '_' + userId2)) &&
             exists(/databases/$(database)/documents/follows/$(userId2 + '_' + userId1));
    }
    
    // Check if a user allows messages from anyone
    function allowsMessagesFromAnyone(userId) {
      let userData = get(/databases/$(database)/documents/users/$(userId)).data;
      return !('messagePrivacy' in userData) || userData.messagePrivacy == 'anyone';
    }
    
    // Check if user can message another user
    function canMessageUser(targetUserId) {
      return !isBlocked(targetUserId) && 
             !hasBlocked(targetUserId) &&
             (allowsMessagesFromAnyone(targetUserId) || 
              areFollowingEachOther(request.auth.uid, targetUserId));
    }
    
    // Validate required fields exist in data
    function hasRequiredFields(data, fields) {
      return data.keys().hasAll(fields);
    }
    
    // Validate string field length
    function isValidLength(str, maxLen) {
      return str is string && str.size() <= maxLen;
    }
    
    // Get other participant in a 2-person conversation
    function getOtherParticipant(participantIds) {
      return participantIds[0] == request.auth.uid ? participantIds[1] : participantIds[0];
    }
    
    // ========================================
    // USERS COLLECTION
    // ========================================
    
    match /users/{userId} {
      // Anyone authenticated can READ user profiles (needed for search, follows, etc.)
      allow read: if isSignedIn();
      
      // Users can CREATE their own profile with required fields
      allow create: if isSignedIn() && 
                       request.auth.uid == userId &&
                       hasRequiredFields(request.resource.data, ['username', 'createdAt']) &&
                       isValidLength(request.resource.data.username, 30) &&
                       (!('bio' in request.resource.data) || isValidLength(request.resource.data.bio, 500));
      
      // Users can UPDATE their own profile OR update follower counts (for follow/unfollow system)
      allow update: if isSignedIn() && (
        // Own profile updates
        (request.auth.uid == userId &&
         (!('username' in request.resource.data.diff(resource.data).affectedKeys()) || 
          isValidLength(request.resource.data.username, 30)) &&
         (!('bio' in request.resource.data.diff(resource.data).affectedKeys()) || 
          isValidLength(request.resource.data.bio, 500))) ||
        // System counter updates (follow/unfollow operations)
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followersCount', 'followingCount', 'updatedAt'])
      );
      
      // Users can DELETE their own profile
      allow delete: if isOwner(userId);
      
      // Privacy subcollections (blockedUsers, mutedUsers, etc.)
      match /blockedUsers/{blockedUserId} {
        // Users can read their own blocked list
        allow read: if isOwner(userId);
        // Users can block/unblock others
        allow write: if isOwner(userId);
      }
      
      match /mutedUsers/{mutedUserId} {
        // Users can read their own muted list
        allow read: if isOwner(userId);
        // Users can mute/unmute others
        allow write: if isOwner(userId);
      }
    }
    
    // ========================================
    // FOLLOWS COLLECTION
    // ========================================
    
    match /follows/{followId} {
      // Anyone can read follows (needed for followers/following lists, feed generation)
      allow read: if isSignedIn();
      
      // Users can create their own follows
      // followId format: {followerId}_{followingId}
      // Support both followerId and followerUserId for backward compatibility
      allow create: if isSignedIn() && 
                       (request.resource.data.followerId == request.auth.uid ||
                        request.resource.data.followerUserId == request.auth.uid) &&
                       hasRequiredFields(request.resource.data, ['createdAt']) &&
                       // Prevent self-follows
                       request.resource.data.followerId != request.resource.data.followingId &&
                       request.resource.data.followerUserId != request.resource.data.followingUserId;
      
      // Users can update their own follows (e.g., changing status)
      allow update: if isSignedIn() && 
                       (resource.data.followerId == request.auth.uid ||
                        resource.data.followerUserId == request.auth.uid);
      
      // Users can delete (unfollow) their own follows
      allow delete: if isSignedIn() && 
                       (resource.data.followerId == request.auth.uid ||
                        resource.data.followerUserId == request.auth.uid);
    }
    
    // ========================================
    // CONVERSATIONS COLLECTION
    // ========================================
    
    match /conversations/{conversationId} {
      allow list: if isSignedIn() && 
                     request.auth.uid in resource.data.participantIds;
      
      allow get: if isSignedIn() && 
                    request.auth.uid in resource.data.participantIds;
      
      allow create: if isSignedIn() && 
                       request.auth.uid in request.resource.data.participantIds &&
                       hasRequiredFields(request.resource.data, ['participantIds', 'createdAt', 'messageCounts']) &&
                       request.resource.data.participantIds.size() == 2 &&
                       request.resource.data.messageCounts.keys().hasAll(request.resource.data.participantIds) &&
                       canMessageUser(getOtherParticipant(request.resource.data.participantIds));
      
      allow update: if isSignedIn() && 
                       request.auth.uid in resource.data.participantIds &&
                       request.auth.uid in request.resource.data.participantIds;
      
      allow delete: if isSignedIn() && 
                       request.auth.uid in resource.data.participantIds;
      
      // Messages subcollection
      match /messages/{messageId} {
        allow read: if isSignedIn() && 
                       request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds;
        
        allow create: if isSignedIn() && 
                         request.auth.uid == request.resource.data.senderId &&
                         hasRequiredFields(request.resource.data, ['senderId', 'text', 'createdAt']) &&
                         isValidLength(request.resource.data.text, 10000) &&
                         request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds &&
                         !isBlocked(getOtherParticipant(get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds)) &&
                         !hasBlocked(getOtherParticipant(get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds)) &&
                         (allowsMessagesFromAnyone(getOtherParticipant(get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds)) ||
                          areFollowingEachOther(request.auth.uid, getOtherParticipant(get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds)) ||
                          (get(/databases/$(database)/documents/conversations/$(conversationId)).data.messageCounts[request.auth.uid] < 1));
        
        allow update, delete: if isSignedIn() && 
                                 request.auth.uid == resource.data.senderId;
      }
    }
    
    // ========================================
    // POSTS COLLECTION
    // ========================================
    
    match /posts/{postId} {
      // Anyone can read posts (needed for feed)
      allow read: if isSignedIn();
      
      // Users can create their own posts
      allow create: if isSignedIn() && 
                       request.auth.uid == request.resource.data.userId &&
                       hasRequiredFields(request.resource.data, ['userId', 'createdAt']) &&
                       (!('content' in request.resource.data) || isValidLength(request.resource.data.content, 5000));
      
      // Post owner can update, OR system can update counters
      allow update: if isSignedIn() && (
        request.auth.uid == resource.data.userId ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['amenCount', 'commentCount', 'repostCount', 'updatedAt'])
      );
      
      // Only post owner can delete
      allow delete: if isSignedIn() && 
                       request.auth.uid == resource.data.userId;
      
      // Comments subcollection
      match /comments/{commentId} {
        allow read: if isSignedIn();
        
        // Comments must have userId matching auth
        allow create: if isSignedIn() &&
                         request.resource.data.userId == request.auth.uid &&
                         hasRequiredFields(request.resource.data, ['userId', 'text', 'createdAt']) &&
                         isValidLength(request.resource.data.text, 2000);
        
        allow update, delete: if isSignedIn() && 
                                 request.auth.uid == resource.data.userId;
      }
      
      // Amens subcollection (likes)
      match /amens/{amenId} {
        allow read: if isSignedIn();
        // amenId should be the user's ID
        allow create, delete: if isSignedIn() && 
                                 request.auth.uid == amenId;
      }
      
      // Reposts subcollection
      match /reposts/{repostId} {
        allow read: if isSignedIn();
        // repostId should be the user's ID
        allow create, delete: if isSignedIn() && 
                                 request.auth.uid == repostId;
      }
    }
    
    // ========================================
    // NOTIFICATIONS
    // ========================================
    
    match /notifications/{notificationId} {
      // Only recipient can read their notifications
      allow read: if isSignedIn() && 
                     resource.data.recipientId == request.auth.uid;
      
      // Anyone can create notifications (system-generated)
      allow create: if isSignedIn() &&
                       hasRequiredFields(request.resource.data, ['recipientId', 'type', 'createdAt']);
      
      // Only recipient can update (e.g., mark as read)
      allow update: if isSignedIn() && 
                       resource.data.recipientId == request.auth.uid;
      
      // Only recipient can delete
      allow delete: if isSignedIn() && 
                       resource.data.recipientId == request.auth.uid;
    }
    
    // ========================================
    // REPORTS
    // ========================================
    
    match /reports/{reportId} {
      // Admin-only reads (implement via Cloud Functions)
      allow read: if false;
      
      // Users can create reports
      allow create: if isSignedIn() && 
                       request.auth.uid == request.resource.data.reporterId &&
                       hasRequiredFields(request.resource.data, ['reporterId', 'reportedId', 'reason', 'createdAt']);
      
      // No updates or deletes
      allow update, delete: if false;
    }
    
    // ========================================
    // COMMUNITIES
    // ========================================
    
    match /communities/{communityId} {
      // Anyone can read communities
      allow read: if isSignedIn();
      
      // Anyone can create a community (becomes creator/admin)
      allow create: if isSignedIn() &&
                       request.resource.data.creatorId == request.auth.uid &&
                       request.auth.uid in request.resource.data.adminIds &&
                       hasRequiredFields(request.resource.data, ['name', 'creatorId', 'adminIds', 'createdAt']) &&
                       isValidLength(request.resource.data.name, 100) &&
                       (!('description' in request.resource.data) || isValidLength(request.resource.data.description, 1000));
      
      // Only admins can update
      allow update: if isSignedIn() && 
                       request.auth.uid in resource.data.adminIds &&
                       // Prevent removing yourself as last admin
                       (request.resource.data.adminIds.size() > 0);
      
      // Only creator can delete
      allow delete: if isSignedIn() && 
                       request.auth.uid == resource.data.creatorId;
      
      // Members subcollection
      match /members/{memberId} {
        allow read: if isSignedIn();
        
        // Anyone can join (create membership)
        allow create: if isSignedIn() &&
                         request.resource.data.userId == request.auth.uid &&
                         hasRequiredFields(request.resource.data, ['userId', 'joinedAt']);
        
        // Users can leave (delete their membership) OR admins can remove members
        allow delete: if isSignedIn() && (
          request.auth.uid == memberId ||
          request.auth.uid in get(/databases/$(database)/documents/communities/$(communityId)).data.adminIds
        );
      }
    }
  }
}
